<html>
<body>
<h1>Class RewardFunction</h1>
<em>Source: reward.cpp</em>
<h2>Methods</h2>
<h3><code>void addRewardComponent(IRewardComponent* rewardComponent)</code></h3>
<ul>
<li><b>Summary</b></li>
<p>RewardFunction can use more than one scalar reward and they are added using this method. Scalar rewards must derive from IRewardComponent</p>
<li><b>Parameters</b></li>
<ul>
<li><i>rewardComponent</i>: The new scalar reward to be added</li>
</ul>
</ul>
<h3><code>double getReward(const State* s, const Action* a, const State* s_p)</code></h3>
<ul>
<li><b>Summary</b></li>
<p>Calculates the total reward based on the different scalar rewards. If we only define one reward function, its value will be returned</p>
<li><b>Parameters</b></li>
<ul>
<li><i>s</i>: Initial state</li>
<li><i>a</i>: Action</li>
<li><i>s_p</i>: Resultant state</li>
</ul>
<li><b>Return Value</b></li>
<p>Calculates the total reward based on the different scalar rewards. If we only define one reward function, its value will be returned</p>
</ul>
<h3><code>void initialize()</code></h3>
<ul>
<li><b>Summary</b></li>
<p>DynamicModel subclasses should call this initialization method after adding the reward functions</p>
</ul>
<h3><code>void override(double reward)</code></h3>
<ul>
<li><b>Summary</b></li>
<p>If we want to override the final reward in some special states (i.e. a negative reward if FAST simulator crashed) we can call this method from the DynamicModel</p>
<li><b>Parameters</b></li>
<ul>
<li><i>reward</i>: The reward we want to give the agent</li>
</ul>
</ul>
</body>
</html>
