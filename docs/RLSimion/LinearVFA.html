<html>
<body>
<h1>Class LinearVFA</h1>
<em>Source: vfa.cpp</em>
<h2>Methods</h2>
<h3><code>double get(const FeatureList *pFeatures,bool bUseFrozenWeights)</code></h3>
<ul>
<li><b>Summary</b></li>
<p>Returns the value of the linear Value Function Approximator for the input state-action given as a list of features.</p>
<li><b>Parameters</b></li>
<ul>
<li><i>pFeatures</i>: Input list of features</li>
<li><i>bUseFrozenWeights</i>: Flag used to determine whether to use the online or target function</li>
</ul>
<li><b>Return Value</b></li>
<p>Returns the value of the linear Value Function Approximator for the input state-action given as a list of features.</p>
</ul>
<h3><code>void saturateOutput(double min, double max)</code></h3>
<ul>
<li><b>Summary</b></li>
<p>Sets the function to saturate its output in range [min,max]</p>
</ul>
<h3><code>void setIndexOffset(unsigned int offset)</code></h3>
<ul>
<li><b>Summary</b></li>
<p>Sets the index offset used. Handy if we want to represent f(s,a) with two different feature maps: one for the state and another one for the action</p>
<li><b>Parameters</b></li>
<ul>
<li><i>offset</i>: Offset added to feature indices</li>
</ul>
</ul>
<h3><code>void add(const FeatureList* pFeatures, double alpha)</code></h3>
<ul>
<li><b>Summary</b></li>
<p>Adds a feature list (each feature has an index and a factor) to the weights in the function. Some of the indices might not belong to this function</p>
<li><b>Parameters</b></li>
<ul>
<li><i>pFeatures</i>: Feature list to be added</li>
<li><i>alpha</i>: Gain parameter used to move current weights toward those in the feature list</li>
</ul>
</ul>
<h3><code>void set(size_t feature, double value)</code></h3>
<ul>
<li><b>Summary</b></li>
<p>Sets the value of a function weight</p>
</ul>
</body>
</html>
